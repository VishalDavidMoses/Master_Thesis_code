import os
import numpy as np
import math
import matplotlib.pyplot as plt

file_path = r'/home/vishaldavidmoses/master_thesis/dynHO2/src/testrun/hoo1p0eVv0j40_gr_3p0_freed_test_run_2.out'


def file_to_combined_lists(file_path, group_size=3):
    combined_lists = []  # Final list to store combined rows
    current_group = []
    with open(file_path, 'r') as file:
        for line in file:
            line = line.strip() #remove leading/trailing whitespace the spaces between the values are ignored in this function  
            if not line: #skips empty lines
                continue
    
            # The below method " .extend" takes each element of the output and separates them by commas to make them an element in the list
            current_group.extend(line.split())
            if len(current_group) == 29:
                combined_lists.append(current_group)
                current_group = []
    return combined_lists


#function definied to add elements to the list and called in the below nested for loop
############################################################################################################################################################################
############################################################################################################################################################################

def inelastic_and_cplx_formation_function(data_to_process,collisional_energy,impact_paramter_max,final_rotational_level_int):
    inelastic_collisions_list = []
    cplx_forming_collisions_list = []
    for trajectory in data_to_process:
        final_rotation_float = trajectory[17] #17th element for each trajectory
        cplx_yes_or_no = trajectory[4]
        if final_rotational_level_int - 1.0 <= final_rotation_float <= final_rotational_level_int + 0.9:
            inelastic_collisions_list.append(final_rotation_float)
            if cplx_yes_or_no != 0:
                cplx_forming_collisions_list.append(final_rotation_float)
    
    no_of_collisions = len(inelastic_collisions_list)
    no_of_cplx_collisions = len(cplx_forming_collisions_list)
            
    return no_of_collisions, no_of_cplx_collisions, total_no_of_trajectories

############################################################################################################################################################################
############################################################################################################################################################################


#Section below is the section I'm currently working on
############################################################################################################################################################################
############################################################################################################################################################################

# example of directory name ---> Jini-01_Ecoll-0.1kcalmol
# example of file name --------> ho2_0.1kcal_v0j01_____fixb_0.0_yyy.out

largest_initial_rotational_level = "blablabla" #Enter file path here
file_to_combined_lists(file_path = largest_initial_rotational_level)

#First designate highest rotational levels
final_rotational_levels = []

for row in combined_data:
    final_rotational_levels.append(row[17])

final_rotational_levels = [float(value) for value in final_rotational_levels]

largest_value = max(final_rotational_levels) 
largest_value = math.ceil(float(largest_value))

directory = r'C:/Temporary_important_folder_1/Thesis_output_data_folder' 
main_dictionary = {}
for folder in os.listdir(directory):
    
    if folder.startswith("j_") and os.path.isdir(os.path.join(directory,folder)):
        #Sample j_ folder name -> j_01_dir (remember to remove the preceding 0s from the directory names)
        folder_name = str(folder)
        ########################### These lines maybe necessary for sorting code I do at the very end
        #indeces_of_folder_name = folder.split('_')                        # This may not be necessary
        #index_0 and index_1 contribute to the rotational level key name
        #index_1 = f"{indeces_of_folder_name[1]}"                          # --------"----------------
        #index_0 =  f"{indeces_of_folder_name[0]}"                         # --------"----------------
        ##########################
        initial_rotational_level = folder_name             #f"{index_0}_{index_1}" This may not even be necessary
        #Initialise a dictionary for the rotational level in the "main dictionary"
        main_dictionary[initial_rotational_level] ={}  
        for E_coll_folder in os.listdir(folder):
            #iterating through the E_coll directories
            if E_coll_folder.startswith("E_coll_"):
                #E_coll directories
                
                E_coll_folder_indeces = E_coll_folder.split("_")
                #sample E_coll folder name -> E_coll_0.05_kcalpmol
                E_coll_keys = f"{E_coll_folder_indeces[0]}_{E_coll_folder_indeces[1]}_{E_coll_folder_indeces[2]}"
                E_coll_float_value = float(E_coll_folder_indeces[2])#By value I mean the actual floating point value, not like dictionary "key" and
                                                                    #"Value"
                
                #Initialising an E_coll dictionary
                main_dictionary[initial_rotational_level][E_coll_keys] ={}
                for data_file in os.listdir(E_coll_folder):
                    if ("_____fixb_") in data_file:
                        # example of file name --------> ho2_0.1kcal_v0j01_____fixb_0.0_yyy.out
                        #retrieving the impact parameter
                        fix_b_part = data_file.split('_____')[1]
                        number_part = fix_b_part.split('_')[1]
                        impact_parameter_float_value = float(number_part)
                        
                        nested_lists = file_to_combined_lists(file_path = data_file)

                        #Highest rotational level designated in the section above the nested for loops in this block
                        
                        
                        for final_rotation in np.arange(1, largest_value + 1, 2):
                            
                            initial_to_final_key = f"{initial_rotational_level}->j_{final_rotation}" #Example of key: j_1->j_10
                            
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key] = []
                            
                            #blebleble
                            no_of_collisions, no_of_cplx_collisions, total_no_of_trajectories = inelastic_and_cplx_formation_function(data_to_process = nested_lists, collisional_energy = E_coll_float_value ,impact_paramter_max = impact_parameter_float_value, final_rotational_level_int = final_rotation)
                            #
                            
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(E_coll_float_value)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(impact_parameter)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(no_of_collisions)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(no_of_cplx_collisions)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(total_no_of_trajectories)
                            
                            
                            
                            #Following code should be done in a separate block which reads the dictionary made
                            ##################################################################################
                            ##################################################################################
                            #for each_key in main_dictionary:
                                #dictionary_key = each_key.split
                                #dictionary_level = dictionary[1]
                                #current_directory = initial_rotational_level.split
                                #current_directory_level = current_directory[1]
                                
                                #if "_low_Ecoll_" and dictionary_level == current_directory_level:
                            #####################################################################################
                            #####################################################################################
                            
                            
#At the end of the day Ronnie I am a file. A file who is a JSON file get that through your head
#We will not process the file. The file is purely for human reading purposes only. So that I, the human, understand the format of the dictionary
#Lil bro, the computer, will just be reading the dictionary
with open("main_dictionary", "w") as f:
    f.write(str(main_dictionary))
                            
                            
                            
############################################################################################################################################################################
############################################################################################################################################################################

############################################################################################################################################################################
############################################################################################################################################################################

#Still a work in progress, really annoying though
#initialise a new dictionary
refined_dictionary = {}
for rotational_levels, rotational_levels_dict_values in main_dictionary:
    #j_keys = rotational_levels.keys #Not needed
    #j_values = rotational_levels.values #Not needed
    elements_of_the_j_key_name = rotational_levels.split("_")#Might not be necessary
    if "j_" in j_keys:
        refined_dictionary[j_keys] = rotational_levels[j_keys]
        #refined_dictionary.append(rotational_levels) #This is not the way to add things to the dictionary
    if "j_" in j_keys:
        refined_dictionary[j_keys] = rotational_levels[j_keys]
        #refined_dictionary.append(rotational_levels) #This is not the way to add things to the dictionary
    elif "j_" and "low_Ecoll" in j_keys:
        for levels, levels_dict_values in refined_dictionary:
            elements_key_name_refined_dict = levels.split("_")
            if elements_key_name_refined_dict[1] == elements_of_the_j_key_name[1]:
                #Have to continue from here, my thoughts are a little eratic with how the code should go
                #But lil bro is cooking
                for E_colls, E_coll_dict_values in main_dictionary[levels]:
                    
                main_dictionary[rotational_levels][E_coll_keys][initial_to_final_key]
            level = levels.keys
            
            if 
    j_dict_values = #May not be needed

############################################################################################################################################################################
############################################################################################################################################################################



#Some variables for the above section (probably not even needed) 
############################################################################################################################################################################
############################################################################################################################################################################
impact_parameter = "blablabla"
impact_parameter_part = impact_parameter ** 2
pi = 3.1416
first_part = pi * impact_parameter_part
second_part = probabilty_part
cross_section = first_part * second_part
############################################################################################################################################################################
############################################################################################################################################################################
