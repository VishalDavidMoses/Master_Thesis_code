import os
import numpy as np
import math
import matplotlib.pyplot as plt

file_path = r'/home/vishaldavidmoses/master_thesis/dynHO2/src/testrun/hoo1p0eVv0j40_gr_3p0_freed_test_run_2.out'


def file_to_combined_lists(file_path, group_size=3):
    combined_lists = []  # Final list to store combined rows
    current_group = []
    with open(file_path, 'r') as file:
        for line in file:
            line = line.strip() #remove leading/trailing whitespace the spaces between the values are ignored in this function  
            if not line: #skips empty lines
                continue
    
            # The below method " .extend" takes each element of the output and separates them by commas to make them an element in the list
            current_group.extend(line.split())
            if len(current_group) == 29:
                combined_lists.append(current_group)
                current_group = []
    return combined_lists


#Section below is the section I'm currently working on
############################################################################################################################################################################
############################################################################################################################################################################

# example of directory name ---> Jini-01_Ecoll-0.1kcalmol
# example of file name --------> ho2_0.1kcal_v0j01_____fixb_0.0_yyy.out

largest_initial_rotational_level = "blablabla" #Enter file path here
file_to_combined_lists(file_path = largest_initial_rotational_level)

#First designate highest rotational levels
final_rotational_levels = []

for row in combined_data:
    final_rotational_levels.append(row[17])

final_rotational_levels = [float(value) for value in final_rotational_levels]

largest_value = max(final_rotational_levels) 
largest_value = math.ceil(float(largest_value))

directory = r'C:/Temporary_important_folder_1/Thesis_output_data_folder' 
main_dictionary = {}
for folder in os.listdir(directory):
    
    if folder.startswith("j_") and os.path.isdir(os.path.join(directory,folder)):
        #Sample j_ folder name -> j_01_dir (remember to remove the preceding 0s from the directory names)
        folder_name = str(folder)
        indeces_of_folder_name = folder.split('_')
        #index_0 and index_1 contribute to the rotational level key name
        index_1 = f"{indeces_of_folder_name[1]}"
        index_0 =  f"{indeces_of_folder_name[0]}"
        initial_rotational_level = f"{index_0}_{index_1}"
        #Initialise a dictionary for the rotational level in the "main dictionary"
        main_dictionary[initial_rotational_level] ={}  
        for E_coll_folder in os.listdir(folder):
            #iterating through the E_coll directories
            if E_coll_folder.startswith("E_coll_"):
                #E_coll directories
                
                E_coll_folder_indeces = E_coll_folder.split("_")
                #sample E_coll folder name -> E_coll_0.05_kcalpmol
                E_coll_keys = f"{E_coll_folder_indeces[0]}_{E_coll_folder_indeces[1]}_{E_coll_folder_indeces[2]}"
                E_coll_float_value = float(E_coll_folder_indeces[2])#By value I mean the actual floating point value, not like dictionary "key" and
                                                                    #"Value"
                
                #Initialising an E_coll dictionary
                main_dictionary[initial_rotational_level][E_coll_keys] ={}
                for data_file in os.listdir(E_coll_folder):
                    if ("_____fixb_") in data_file:
                        # example of file name --------> ho2_0.1kcal_v0j01_____fixb_0.0_yyy.out
                        #retrieving the impact parameter
                        fix_b_part = data_file.split('_____')[1]
                        number_part = fix_b_part.split('_')[1]
                        impact_parameter = float(number_part)
                        
                        file_to_combined_lists(file_path = data_file)

                        
                        #Highest rotational level designated in the section above the nested for loops in this block
                        #
                        
                        #Code below probaly does not belong here as I already did it before the nested for loop started
                        
                        for final_rotation in np.arange(1, largest_value + 1, 2):
                            
                            initial_to_final_key = f"{initial_rotational_level}->j_{final_rotation}" #Example of key: j_1->j_10
                            
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key] =[]
                            
                            #
                            
                            #
                            
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(E_coll_float_value)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(impact_parameter)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(no_of_collisions)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(no_of_cplx_collisions)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(total_no_of_trajectories)
                            
############################################################################################################################################################################
############################################################################################################################################################################

#Some variables for the above section (probably not even needed) 
############################################################################################################################################################################
############################################################################################################################################################################
impact_parameter = "blablabla"
impact_parameter_part = impact_parameter ** 2
pi = 3.1416
first_part = pi * impact_parameter_part
second_part = probabilty_part
cross_section = first_part * second_part
############################################################################################################################################################################
############################################################################################################################################################################

#function definied to add elements to the list and called in the above for loop
############################################################################################################################################################################
############################################################################################################################################################################

def inelastic_and_cplx_formation_function(data_to_process,collisional_energy,impact_paramter_max,final_rotational_level_int):
    inelastic_collisions_list = []
    cplx_forming_collisions_list = []
    for trajectory in data_to_process:
        final_rotation_float = trajectory[17] #17th element for each trajectory
        cplx_yes_or_no = trajectory[4]
        if final_rotational_level - 1.0 <= final_rotation_float <= final_rotational_level + 0.9:
            inelastic_collisions_list.append(final_rotation_float)
            if cplx_yes_or_no != 0:
                cplx_forming_collisions_list.append(final_rotation_float)
    
    no_of_collisions = len(inelastic_collisions_list)
    no_of_cplx_collisions = len(cplx_forming_collisions_list)
            
    return no_of_collisions, no_of_cplx_collisions, total_no_of_trajectories

