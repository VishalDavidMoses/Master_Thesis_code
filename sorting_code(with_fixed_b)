import os
import numpy as np
import math
import matplotlib.pyplot as plt

file_path = r'/home/vishaldavidmoses/master_thesis/dynHO2/src/testrun/hoo1p0eVv0j40_gr_3p0_freed_test_run_2.out'


def file_to_combined_lists(file_path, group_size=3):
    combined_lists = []  # Final list to store combined rows
    current_group = []
    with open(file_path, 'r') as file:
        for line in file:
            line = line.strip() #remove leading/trailing whitespace the spaces between the values are ignored in this function  
            if not line: #skips empty lines
                continue
    
            # The below method " .extend" takes each element of the output and separates them by commas to make them an element in the list
            current_group.extend(line.split())
            if len(current_group) == 29:
                combined_lists.append(current_group)
                current_group = []
    return combined_lists


#function definied to add elements to the list and called in the below nested for loop
############################################################################################################################################################################
############################################################################################################################################################################

def inelastic_and_cplx_formation_function(data_to_process,collisional_energy,impact_paramter_max,final_rotational_level_int):
    inelastic_collisions_list = []
    cplx_forming_collisions_list = []
    for trajectory in data_to_process:
        final_rotation_float = float(trajectory[17]) #17th element for each trajectory
        cplx_yes_or_no = float(trajectory[4]) #4th element in each trajectory
        if final_rotational_level_int - 1.0 <= final_rotation_float <= final_rotational_level_int + 0.9:
            #print(final_rotational_level_int) #In cases of error uncomment the line
            inelastic_collisions_list.append(final_rotation_float)
            if cplx_yes_or_no != 0:
                cplx_forming_collisions_list.append(final_rotation_float)
    
    no_of_collisions = len(inelastic_collisions_list)
    no_of_cplx_collisions = len(cplx_forming_collisions_list)
    last_trajectory = data_to_process[-1]
    total_no_of_trajectories = float(last_trajectory[0])
            
    return no_of_collisions, no_of_cplx_collisions, total_no_of_trajectories

############################################################################################################################################################################
############################################################################################################################################################################


#Section below is the section I'm currently working on
############################################################################################################################################################################
############################################################################################################################################################################

# example of directory name ---> Jini-01_Ecoll-0.1kcalmol
# example of file name --------> ho2_0.1kcal_v0j01_____fixb_0.0_yyy.out

largest_initial_rotational_level = "C:/Temporary_important_folder_1/Thesis_output_data_folder/j_21_dir/E_coll_7.0_kcalpmol/ho2_7.0kcal_v0j21_____fixb_4.0_yyy.out" #Enter file path here
combined_data = file_to_combined_lists(file_path = largest_initial_rotational_level)

#First designate highest rotational levels
final_rotational_levels = []

for row in combined_data:
    final_rotational_levels.append(row[17])

final_rotational_levels = [float(value) for value in final_rotational_levels]

largest_value = max(final_rotational_levels) 
largest_value = math.ceil(float(largest_value))

directory = r'C:/Temporary_important_folder_1/Thesis_output_data_folder' 
main_dictionary = {}
for folder in os.listdir(directory):
    
    if folder.startswith("j_") and os.path.isdir(os.path.join(directory,folder)):
        #Sample j_ folder name -> j_01_dir (remember to remove the preceding 0s from the directory names)
        folder_name = str(folder)
        ########################### These lines maybe necessary for sorting code I do at the very end
        #indeces_of_folder_name = folder.split('_')                        # This may not be necessary
        #index_0 and index_1 contribute to the rotational level key name
        #index_1 = f"{indeces_of_folder_name[1]}"                          # --------"----------------
        #index_0 =  f"{indeces_of_folder_name[0]}"                         # --------"----------------
        ##########################
        initial_rotational_level = folder_name             #f"{index_0}_{index_1}" This may not even be necessary
        #Initialise a dictionary for the rotational level in the "main dictionary"
        main_dictionary[initial_rotational_level] ={}  
        rotational_dirs = os.path.join(directory,folder)
        
        for E_coll_folder in os.listdir(rotational_dirs):
            #iterating through the E_coll directories
            if E_coll_folder.startswith("E_coll_"):
                #E_coll directories
                
                E_coll_folder_indeces = E_coll_folder.split("_")
                #sample E_coll folder name -> E_coll_0.05_kcalpmol
                E_coll_keys = f"{E_coll_folder_indeces[0]}_{E_coll_folder_indeces[1]}_{E_coll_folder_indeces[2]}"
                E_coll_float_value = float(E_coll_folder_indeces[2])#By value I mean the actual floating point value, not like dictionary "key" and
                                                                    #"Value"
                
                #Initialising an E_coll dictionary
                main_dictionary[initial_rotational_level][E_coll_keys] ={}
                
                E_coll_dirs = os.path.join(rotational_dirs,E_coll_folder)
                
                for data_file in os.listdir(E_coll_dirs):
                    if ("_____fixb_") in data_file:
                        # example of file name --------> ho2_0.1kcal_v0j01_____fixb_0.0_yyy.out
                        #retrieving the impact parameter
                        fix_b_part = data_file.split('_____')[1]
                        number_part = fix_b_part.split('_')[1]
                        impact_parameter_float_value = float(number_part)
                        
                        output_file_path = os.path.join(E_coll_dirs,data_file)
                        
                        nested_lists = file_to_combined_lists(file_path = output_file_path)
                        #with open("nested_list", "w") as f: #!!!!!!! UNCOMMENT ON IN CASE OF ERROR
                            #f.write(str(nested_lists))

                        #Highest rotational level designated in the section above the nested for loops in this block
                        
                        
                        for final_rotation in np.arange(1, largest_value + 1, 2):
                            
                            #print the final_rotation
                            #print(final_rotation) #UNCOMMENT ONLY IN CASE OF ERROR
                            initial_to_final_key = f"{initial_rotational_level}->j_{final_rotation}" #Example of key: j_1->j_10
                            
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key] = []
                            
                            #blebleble
                            no_of_collisions, no_of_cplx_collisions, total_no_of_trajectories = inelastic_and_cplx_formation_function(data_to_process = nested_lists, collisional_energy = E_coll_float_value ,impact_paramter_max = impact_parameter_float_value, final_rotational_level_int = final_rotation)
                            #
                            
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(E_coll_float_value)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(impact_parameter_float_value)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(no_of_collisions)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(no_of_cplx_collisions)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(total_no_of_trajectories)
                            
#At the end of the day Ronnie I am a file. A file who is a JSON file get that through your head
#We will not process the file. The file is purely for human reading purposes only. So that I, the human, understand the format of the dictionary
#And lil bro, the computer, will just be reading the dictionary
with open("main_dictionary", "w") as f:
    f.write(str(main_dictionary))



############################################################################################################################################################################
############################################################################################################################################################################

############################################################################################################################################################################
############################################################################################################################################################################

import ast

with open("main_dictionary", "r") as f:
    contents = f.read()
    
new_main_dictionary = ast.literal_eval(contents)
new_main_dictionary

############################################################################################################################################################################
############################################################################################################################################################################

############################################################################################################################################################################
############################################################################################################################################################################

refined_dictionary={}

for rotational_levels, rotational_levels_dict_values in new_main_dictionary.items():
    j_keys = rotational_levels #Not needed, but already present in following code so I'll keep it
    j_values = rotational_levels_dict_values #Not needed, but already present in following code so I'll keep it
    #elements_of_the_j_key_name = rotational_levels.split("_")#Might not be necessary
    if "j_"  and not "low_Ecoll" in j_keys:
        refined_dictionary[j_keys] = new_main_dictionary[j_keys]
        #refined_dictionary.append(rotational_levels) #This is not the way to add things to the dictionary
    
    elif "j_" and "low_Ecoll" in j_keys:
        
        for levels, levels_dict_values in refined_dictionary.items():
            level_name_list = levels.split("_") # From the refined dictionary
            
            main_dict_name_split = j_keys.split("_")
            if level_name_list[1] == main_dict_name_split[1]:
                collision_energies_dict = refined_dictionary[levels] #The dictionary within each Collisional energy
                for E_colls, E_coll_values in collision_energies_dict.items():
                    final_rotations_dict = refined_dictionary[levels][E_colls]
                    for final_rotations, final_rotation_values in final_rotations_dict.items():
                        final_rotations_key_name_elements = final_rotations.split("_")
                        final_rot_list = final_rotation_values
                        rotational_dict = new_main_dictionary[levels][E_colls]
                        for main_dict_rots, main_dict_rot_values in rotational_dict.items():
                            final_rots_key_name_elements = main_dict_rots.split("_")
                            main_dict_list = main_dict_rot_values
                            if final_rotations_key_name_elements[1] == final_rots_key_name_elements[1]:
                                new_inel = float(final_rot_list[2]) + float(main_dict_list[2])
                                new_cplx = float(final_rot_list[3]) + float(main_dict_list[3])
                                new_total = float(final_rot_list[4]) + float(main_dict_list[4])
                                final_rot_list[2] = new_inel
                                final_rot_list[3] = new_cplx
                                final_rot_list[4] = new_total
refined_dictionary
#with open("refined_dict", "w") as f:
    #f.write(str(refined_dictionary))
############################################################################################################################################################################
############################################################################################################################################################################



#Some variables for the above section (probably not even needed) 
############################################################################################################################################################################
############################################################################################################################################################################
impact_parameter = "blablabla"
impact_parameter_part = impact_parameter ** 2
pi = 3.1416
first_part = pi * impact_parameter_part
second_part = probabilty_part
cross_section = first_part * second_part
############################################################################################################################################################################
############################################################################################################################################################################
