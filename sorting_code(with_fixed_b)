import os
import numpy as np
import math
import matplotlib.pyplot as plt

file_path = r'/home/vishaldavidmoses/master_thesis/dynHO2/src/testrun/hoo1p0eVv0j40_gr_3p0_freed_test_run_2.out'


def file_to_combined_lists(file_path, group_size=3):
    combined_lists = []  # Final list to store combined rows
    current_group = []
    with open(file_path, 'r') as file:
        for line in file:
            line = line.strip() #remove leading/trailing whitespace the spaces between the values are ignored in this function  
            if not line: #skips empty lines
                continue
    
            # The below method " .extend" takes each element of the output and separates them by commas to make them an element in the list
            current_group.extend(line.split())
            if len(current_group) == 29:
                combined_lists.append(current_group)
                current_group = []
    return combined_lists


#function definied to add elements to the list and called in the below nested for loop
############################################################################################################################################################################
############################################################################################################################################################################

def inelastic_and_cplx_formation_function(data_to_process,collisional_energy,impact_paramter_max,final_rotational_level_int):
    inelastic_collisions_list = []
    cplx_forming_collisions_list = []
    for trajectory in data_to_process:
        final_rotation_float = float(trajectory[17]) #17th element for each trajectory
        cplx_yes_or_no = float(trajectory[4]) #4th element in each trajectory
        if final_rotational_level_int - 1.0 <= final_rotation_float <= final_rotational_level_int + 0.9:
            #print(final_rotational_level_int) #In cases of error uncomment the line
            inelastic_collisions_list.append(final_rotation_float)
            if cplx_yes_or_no != 0:
                cplx_forming_collisions_list.append(final_rotation_float)
    
    no_of_collisions = len(inelastic_collisions_list)
    no_of_cplx_collisions = len(cplx_forming_collisions_list)
    last_trajectory = data_to_process[-1]
    total_no_of_trajectories = float(last_trajectory[0])
            
    return no_of_collisions, no_of_cplx_collisions, total_no_of_trajectories

############################################################################################################################################################################
############################################################################################################################################################################


#Section below is the section I'm currently working on
############################################################################################################################################################################
############################################################################################################################################################################

# example of directory name ---> Jini-01_Ecoll-0.1kcalmol
# example of file name --------> ho2_0.1kcal_v0j01_____fixb_0.0_yyy.out

largest_initial_rotational_level = "C:/Temporary_important_folder_1/Thesis_output_data_folder/j_21_dir/E_coll_7.0_kcalpmol/ho2_7.0kcal_v0j21_____fixb_4.0_yyy.out" #Enter file path here
combined_data = file_to_combined_lists(file_path = largest_initial_rotational_level)

#First designate highest rotational levels
final_rotational_levels = []

for row in combined_data:
    final_rotational_levels.append(row[17])

final_rotational_levels = [float(value) for value in final_rotational_levels]

largest_value = max(final_rotational_levels) 
largest_value = math.ceil(float(largest_value))

directory = r'C:/Temporary_important_folder_1/Thesis_output_data_folder' 
main_dictionary = {}
for folder in os.listdir(directory):
    
    if folder.startswith("j_") and os.path.isdir(os.path.join(directory,folder)):
        #Sample j_ folder name -> j_01_dir (remember to remove the preceding 0s from the directory names)
        folder_name = str(folder)
        ########################### These lines maybe necessary for sorting code I do at the very end
        #indeces_of_folder_name = folder.split('_')                        # This may not be necessary
        #index_0 and index_1 contribute to the rotational level key name
        #index_1 = f"{indeces_of_folder_name[1]}"                          # --------"----------------
        #index_0 =  f"{indeces_of_folder_name[0]}"                         # --------"----------------
        ##########################
        initial_rotational_level = folder_name             #f"{index_0}_{index_1}" This may not even be necessary
        #Initialise a dictionary for the rotational level in the "main dictionary"
        main_dictionary[initial_rotational_level] ={}  
        rotational_dirs = os.path.join(directory,folder)
        
        for E_coll_folder in os.listdir(rotational_dirs):
            #iterating through the E_coll directories
            if E_coll_folder.startswith("E_coll_"):
                #E_coll directories
                
                E_coll_folder_indeces = E_coll_folder.split("_")
                #sample E_coll folder name -> E_coll_0.05_kcalpmol
                E_coll_keys = f"{E_coll_folder_indeces[0]}_{E_coll_folder_indeces[1]}_{E_coll_folder_indeces[2]}"
                E_coll_float_value = float(E_coll_folder_indeces[2])#By value I mean the actual floating point value, not like dictionary "key" and
                                                                    #"Value"
                
                #Initialising an E_coll dictionary
                main_dictionary[initial_rotational_level][E_coll_keys] ={}
                
                E_coll_dirs = os.path.join(rotational_dirs,E_coll_folder)
                
                for data_file in os.listdir(E_coll_dirs):
                    if ("_____fixb_") in data_file:
                        # example of file name --------> ho2_0.1kcal_v0j01_____fixb_0.0_yyy.out
                        #retrieving the impact parameter
                        fix_b_part = data_file.split('_____')[1]
                        number_part = fix_b_part.split('_')[1]
                        impact_parameter_float_value = float(number_part)
                        
                        output_file_path = os.path.join(E_coll_dirs,data_file)
                        
                        nested_lists = file_to_combined_lists(file_path = output_file_path)
                        #with open("nested_list", "w") as f: #!!!!!!! UNCOMMENT ON IN CASE OF ERROR
                            #f.write(str(nested_lists))

                        #Highest rotational level designated in the section above the nested for loops in this block
                        
                        
                        for final_rotation in np.arange(1, largest_value + 1, 2):
                            
                            #print the final_rotation
                            #print(final_rotation) #UNCOMMENT ONLY IN CASE OF ERROR
                            initial_to_final_key = f"{initial_rotational_level}->j_{final_rotation}" #Example of key: j_1->j_10
                            
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key] = []
                            
                            #blebleble
                            no_of_collisions, no_of_cplx_collisions, total_no_of_trajectories = inelastic_and_cplx_formation_function(data_to_process = nested_lists, collisional_energy = E_coll_float_value ,impact_paramter_max = impact_parameter_float_value, final_rotational_level_int = final_rotation)
                            #
                            
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(E_coll_float_value)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(impact_parameter_float_value)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(no_of_collisions)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(no_of_cplx_collisions)
                            main_dictionary[initial_rotational_level][E_coll_keys][initial_to_final_key].append(total_no_of_trajectories)
                            
#At the end of the day Ronnie I am a file. A file who is a JSON file get that through your head
#We will not process the file. The file is purely for human reading purposes only. So that I, the human, understand the format of the dictionary
#And lil bro, the computer, will just be reading the dictionary
with open("main_dictionary", "w") as f:
    f.write(str(main_dictionary))



############################################################################################################################################################################
############################################################################################################################################################################

############################################################################################################################################################################
############################################################################################################################################################################

import ast

with open("main_dictionary", "r") as f:
    contents = f.read()
    
new_main_dictionary = ast.literal_eval(contents)
new_main_dictionary

############################################################################################################################################################################
############################################################################################################################################################################

############################################################################################################################################################################
############################################################################################################################################################################

refined_dictionary={}

for rotational_levels, rotational_levels_dict_values in new_main_dictionary.items():
    j_keys = rotational_levels #Not needed, but already present in following code so I'll keep it
    j_values = rotational_levels_dict_values #Not needed, but already present in following code so I'll keep it
    #elements_of_the_j_key_name = rotational_levels.split("_")#Might not be necessary
    if "j_"  and not "low_Ecoll" in j_keys:
        refined_dictionary[j_keys] = new_main_dictionary[j_keys]
        #refined_dictionary.append(rotational_levels) #This is not the way to add things to the dictionary

with open("refined_dict", "w") as f:
    f.write(str(refined_dictionary))

refined_dictionary

############################################################################################################################################################################
############################################################################################################################################################################

############################################################################################################################################################################
############################################################################################################################################################################
import os
import numpy as np
import math
import matplotlib.pyplot as plt
import ast
import copy

with open("main_dictionary", "r") as f:
    contents = f.read()
    
new_main_dictionary = ast.literal_eval(contents)
new_main_dictionary


largest_initial_rotational_level = "C:/Temporary_important_folder_1/Thesis_output_data_folder/j_21_dir/E_coll_7.0_kcalpmol/ho2_7.0kcal_v0j21_____fixb_4.0_yyy.out" #Enter file path here
combined_data = file_to_combined_lists(file_path = largest_initial_rotational_level)

#First designate highest rotational levels
final_rotational_levels = []

for row in combined_data:
    final_rotational_levels.append(row[17])

final_rotational_levels = [float(value) for value in final_rotational_levels]

largest_value = max(final_rotational_levels) 
largest_value = math.ceil(float(largest_value))


#Initialise E_coll list
low_E_colls = [0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.8]
#initialise final rotation level list
final_rotation_list = []
for final_rotation in np.arange(1, largest_value + 1, 2):
    final_rotation_float = int(final_rotation)
    final_rotation_list.append(final_rotation_float)

print(final_rotation_list)
print(low_E_colls)


#Make "a_dictionary"
a_dictionary = {}
for main_init_levels, main_init_levels_values in new_main_dictionary.items():
    #From this point on try not to call the nested dict keys and values make them as you go now
    if "low_Ecoll_" not in main_init_levels:
        #blablabla
        a_dictionary[main_init_levels] = copy.deepcopy(new_main_dictionary[main_init_levels])
    elif "low_Ecoll" in main_init_levels:
        
        main_init_levels_key_split = main_init_levels.split("_") #example of low E_coll j initial key 'j_01_dir_low_Ecoll_1'
        no_low_Ecoll_j_init_key = f"{main_init_levels_key_split[0]}_{main_init_levels_key_split[1]}_{main_init_levels_key_split[2]}"
        
        for collisional_energy in low_E_colls:
            E_coll_key = f"E_coll_{collisional_energy}"
            for j_final in final_rotation_list:
                
                j_transitions_key_w_out_low_Ecoll = f"{no_low_Ecoll_j_init_key}->j_{j_final}" #This is the key WITH NO low E_coll
                j_transitions_key_low_Ecoll = f"{main_init_levels}->j_{j_final}" #This is the key WITH low E_coll
                relevant_a_dict_j_init_ = no_low_Ecoll_j_init_key 
                
                #call the relevant nested dictionary key-value pairs in both the dictionaries
                a_dict_comp = a_dictionary[relevant_a_dict_j_init_][E_coll_key][j_transitions_key_w_out_low_Ecoll]
                new_main_dict_comp = new_main_dictionary[main_init_levels][E_coll_key][j_transitions_key_low_Ecoll]
                
                print(f"a_dictionary list ={a_dict_comp}")
                
                new_inel_value = a_dict_comp[2] + new_main_dict_comp[2] 
                new_cplx_frmtn_value = a_dict_comp[3] + new_main_dict_comp[3]
                new_total_traj_value = a_dict_comp[4] + new_main_dict_comp[4]
                
                #Call the same relevant nest dictionary key-value pairs but this time ONLY for the a_dictionary dictionary
                a_dict_comp[2] = new_inel_value
                a_dict_comp[3] = new_cplx_frmtn_value
                a_dict_comp[4] = new_total_traj_value
                
                print(f"a_dictionary component ={j_transitions_key_w_out_low_Ecoll} and new_main_dictionary component ={j_transitions_key_low_Ecoll}")
                print(f"a_dictionary list ={a_dict_comp} and new_main_dictionary list ={new_main_dict_comp}")
                print(f"new_inel_value = {new_inel_value}, new_cplx_frmtn_value = {new_cplx_frmtn_value}, new_total_traj_value = {new_total_traj_value}")


with open("final_dictionary", "w") as f:
    f.write(str(a_dictionary))
